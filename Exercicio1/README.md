# engenharia-software-bertoti
O que exatamente queremos dizer com engenharia de software? O que distingue "engenharia de software" de "programação" ou "ciência da computação"? E por que o Google teria uma perspectiva única para adicionar ao corpus da literatura anterior de engenharia de software escrita nos últimos 50 anos?
 
Os termos "programação" e "engenharia de software" têm sido usados de forma intercambiável há algum tempo em nosso setor, embora cada termo tenha uma ênfase diferente e implicações diferentes. Estudantes universitários tendem a estudar ciência da computação e conseguir empregos escrevendo código como "programadores".
 
"Engenharia de software", no entanto, soa mais sério, como se implicasse a aplicação de algum conhecimento teórico para construir algo real e preciso. Engenheiros mecânicos, engenheiros civis, engenheiros aeronáuticos e outros Todos eles trabalham no mundo real e usam a aplicação de seus conhecimentos teóricos para criar algo real. Os engenheiros de software também criam "algo real", embora seja menos tangível do que as coisas que outros engenheiros criam.
 
Ao contrário das profissões de engenharia mais estabelecidas, a teoria ou prática atual da engenharia de software não é tão rigorosa. Os engenheiros aeronáuticos devem seguir diretrizes e práticas rígidas, pois erros em seus cálculos podem causar danos reais; A programação, em geral, tradicionalmente não segue práticas tão rigorosas. Mas, à medida que o software se torna mais integrado em nossas vidas, devemos adotar e confiar em métodos de engenharia mais rigorosos. Esperamos que este livro ajude outras pessoas a ver um caminho para práticas de software mais confiáveis.

## Comentário:

Talvez pensam que engenheiros de software nao criam coisas do mundo real com as outras engenharias por um dos pilares de pogramação orientada a ogjetos ser a abstratacao onde devemos abstrair coisas do mundo real para software onde da uma falsa impressao de os softwares nao serem reais.

__________________________________________________________________________________________________________________________________________________________________________________________________________________
# Programação ao longo do tempo

Propomos que a "engenharia de software" engloba não apenas o ato de escrever código, mas todas as ferramentas e processos que uma organização usa para construir e manter esse código ao longo do tempo. Quais práticas uma organização de software pode introduzir para manter seu código valioso a longo prazo? Como os engenheiros podem tornar uma base de código mais sustentável e a própria disciplina de engenharia de software mais rigorosa? Não temos respostas fundamentais para essas perguntas, mas esperamos que a experiência coletiva do Google nas últimas duas décadas ilumine possíveis caminhos para encontrar essas respostas.
 
Um insight importante que compartilhamos neste livro é que a engenharia de software pode ser pensada como "programação integrada ao longo do tempo". Que práticas podemos introduzir em nosso código para torná-lo sustentável - capaz de reagir às mudanças necessárias - ao longo de seu ciclo de vida, desde a concepção até a introdução, a manutenção e a descontinuação?
 
O livro enfatiza três princípios fundamentais que achamos que as organizações de software devem ter em mente ao projetar, arquitetar e escrever seu código:
 
Tempo e Mudança
Como o código precisará se adaptar ao longo de sua vida útil
 
Escala e crescimento
Como uma organização precisará se adaptar à medida que evolui
 
Compensações e custos
Como uma organização toma decisões, com base nas lições de Tempo e Mudança e Escala e Crescimento

## Comentário:

Acredito que o principio de ter um software robusto e valioso passe pelo que ele deve ter uma escalabilidade, uma boa manutenabilidade onde possa gerar menos custo de producao e manutencao;
______________________________________________________________________________________________________________________________________________________________________________________________________________________
# Exemplos de Tradeoffs
- Tempo de desenvolvimento X Qualidade
- Escalabilidade X Simplicidade
- Custo X Funcionabilidade
<<<<<<< HEAD

____________________________________________________________________________________________________________________________________________________________
=======
- ________________________________________________________________________________________________________

- # Diagrama UML
- ![image](https://github.com/user-attachments/assets/ac5a8bff-6bb7-4ec9-adac-bb8750c41cca)

__________________________________________________________________________________________________________
# Testes Unitários
![image](https://github.com/user-attachments/assets/11300ac1-d9af-4fa6-b3fa-dcec46024822)


__________________________________________________________________________________________________________
# Classe Venda
![image](https://github.com/user-attachments/assets/101d94c0-4265-43d5-8465-0ad532f92553)

_________________________________________________________________________________________________________
# Classe Produto
![image](https://github.com/user-attachments/assets/018af2fd-e434-4627-a5e6-d7809b726a39)


__________________________________________________________________________________________________________
>>>>>>> 3c6eef3b1a8a4003dce668efb171808905cbd289
